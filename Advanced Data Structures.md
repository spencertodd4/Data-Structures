###Linked Lists
Add at end O(1)
Delete at end O(1)
Find O(n)
Positional access O(1)

###Binary Tree
**sorted**
Add O (log2 n)
Delete O (log2 n)
Print O (n)
Find max O (log2 n)

###Hash Table
**unordered, less space efficient**
Add O(1)
Contains (check if exists) -> O(1)
Positional access â€“ NA (no predictable order)

###ArrayList
Add O(1) or O(n)       Most cases this is O(1), but if a resized is forced O(n)
Insert O(n)            Everything has to be shifted to the right
Sort O(n log2 n)
Delete O(n)

